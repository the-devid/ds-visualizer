# 2-3 Дерево

Это - описание структуры данных 2-3 Дерево (конкретно B+-дерева степени 2), а также её имплементации в данном проекте.

### Почему этот документ существует

Во-первых, я не смог найти внятного материала с описанием того, как реализовать запросы к 2-3 дереву. Много слов, мало конкретики, неработающий псевдокод или его отсутствие. И без внятного пояснения асимптотической сложности выполнения запросов. А может просто я слишком привередлив. Остаётся надеяться что этот материал выйдет сносным и может быть для кого-то полезным. Во-вторых, реализация писалась не один вечер, несколько раз переписывалась и я нашёл необходимым выписать для себя пояснения к коду, который я написал, чтобы быть способным понять его спустя время. В-третьих, имплементировать 2-3 дерево было проще, если предварительно сформулировать и выписать алгоритмы. Кроме того, так как это учебный проект, мне всё равно было необходимо написать теоретическую часть и пояснения к коду. Поэтому пояснения немного вычурные и канеляритные - чтобы мне потом меньше нужно было переписывать для отчёта.

## Внутренняя структура

2-3 Дерево - это дерево поиска. У каждой нелистовой вершины 2 или 3 ребёнка, все листья находятся на одной высоте. Ключи (хранимые в дереве элементы) непосредственно хранятся только в листьях. В промежуточных вершинах же хранятся только копии ключей из листьев. А конкретно для каждого ребенка предлагается хранить максимальный ключ в поддереве этого ребенка. Ключи в каждой вершине должны быть упорядочены по возрастанию. Отметим, что обычно предлагается хранить копии ключей из всех детей кроме последнего. Однако далее станет понятно почему мы храним и копию максимального ключа в последнем ребенке. Более того в данной реализации каждый лист хранит 2 или 3 ключа сразу (исключение только в случае дерева, хранящего 1 ключ - там корень дерева, он же лист, хранит этот ключ).

Сразу можно отметить, что при заданных условиях высота дерева $h = O(log n)$, где $n$ это количество хранимых ключей. В самом деле, на каждом уровне дерева от корня до листьев количество вершин в очередном слое по крайней мере удваивается по сравнению с предыдущим уровнем, ведь у каждой вершины есть хотя бы два ребёнка. А так как все листья находятся на одной высоте, и именно в них хранятся $n$ ключей, отсюда легко видеть логарифмическую зависимость высоты дерева от количества ключей.

Реализация представлена шаблоном, зависящим от параметра `T` - типа данных, которые хранятся в дереве. Дерево, как множество вершин, хранится в виде набора узлов. Они представляются структурой `Node`. Каждый узел хранит в себе `std::vector` ключей `keys`, указателей на детей `children` и указатель на предка `parent`. Указатели на детей - `std::unique_ptr`, чтобы при удалении указателя автоматически чистилась память и вызывались деструкторы. Дерево задаётся своим корнем `std::unique_ptr<Node> root_`. Использование `std::unique_ptr` позволяет безопасно владеть памятью.

### Примечание про ключи
В первоначальном варианте реализации ключи явно копируются в промежуточные вершины. Но, конечно, в случае хранения тяжеловесных данных, копирование которых неразумно, можно поступить иначе. Мы можем хранить ключи не просто как `T`, а как `std::shared_ptr<const T>`. Может казаться, что по-хорошему владеть ключами должны листья, а промежуточные вершины только ссылаться на данные. Но подобный подход привел бы к появлению отдельной сущности "листьев", что привело бы к усложнению реализации. Кроме того при удалении ключа из дерева он первым делом удаляется из листа, что привело бы к появлению висячих указателей.

## Схема работы

Мы хотим уметь добавлять и удалять ключ, а также проверять наличие ключа в дереве. За эти действия отвечают соответственно методы `Insert(x)`, `Erase(x)` и `Contains(x)`. Для их реализации мы также определим всппомогательные методы `UpdateKeys(Node*)`, `SplitNode(Node*)` и `SearchByLowerBound(x)`.

`SearchByLowerBound(x)` будет спускаться по дереву от корня до листа и возвращать такую вершину, где находится первый ключ, больший либо равный заданному (то есть выступает в некотором роде аналогом `std::set::lower_bound`). `UpdateKeys(Node*)` будет проходить от вершины по её предкам и обновлять хранящиеся в них `keys` в соответствии с тем, что в реальности лежит в сыновьях соответствующего предка. Нужна эта функция на случай, когда добавляется или удаляется ключ и соответственно необходимо обновить информацию в предках. `SplitNode(Node*)` же будет "разделять" вершину, в которой оказалось 4 ключа на 2 вершины с двумя ключами в каждом (и соответственно разделяя между ними детей вершины). Кроме того, так как в процессе разделения вершины на две у её предка увеличивается количество сыновей (и хранимых ключей), функция будет разделять и предков вершины пока это необходимо.

`Contains(x)` будет просто вызывать спуск по дереву и проверять наличие ключа в найденном листе. `Insert(x)` будет спускаться до нужного листа, вставлять ключ и вызывать обновление ключей у родителей, а также разделение вершины. `Erase(x)` (самая неприятная часть) будет спускаться в лист, удалять ключ если он есть. А затем, если в листе остался всего один ключ, его нужно переложить в соседний лист. При необходимости соседний лист нужно будет разделить. А также могло оказаться, что теперь в родителе удаленного листа остался один ребенок и один ключ, которые надо будет перекинуть к соседу. И так далее для предков выше.

## Методы

### Проверка наличия ключа в дереве

Осуществляется через метод `Contains`. В аргументе передается ключ `x`, который в дереве и ищется. Возвращается `true`, если ключ в дереве есть и `false` иначе. 

Просто вызывается функция спуска по дереву, которая возвращает лист, в котором должен находиться `x` если он вообще в дереве есть. После обработки крайних случаев достаточно просто проверить наличие `x` в массиве ключей у листа. 

Очевидно, что время работы равно времени работы `SearchByLowerBound`, которое составляет $O(\log n)$.

### Добавление ключа

Осуществляется через метод `Insert`. В аргументе передается вставляемый ключ `x`, возвращается `true`, если ключ действительно был вставлен в дерево, или `false`, если он и так в дереве был.

Сначала проверяем, что дерево непусто. В противном случае следует создать новый корень, хранящий этот ключ и закончить алгоритм. Иначе вызывается спуск по дереву, который возвращает лист, куда ключ надо вставить. Если был возвращён `nullptr`, значит дерево состоит из 0 элементов и надо создать корень, хранящий новый ключ. Если в листе ключ и так содержится, то можно сразу вернуть `false`. Иначе необходимо вставить ключ `x` перед первым таким ключом `key`, что `x < key`. Далее необходимо обновить ключи на пути от листа до корня и вызвать `SplitNode`, на случай если лист стал слишком большим. 

Время работы складывается из времени работы `SearchByLowerBound`, `UpdateKeys` и `SplitNode`. Но все они работают за высоту дерева, то есть итоговое время работы запроса вставки - $O(\log n)$.

### Удаление ключа

Осуществляется через метод `Erase`. В аргументе передается удаляемый ключ `x`, возвращается `true`, если ключ действительно был удалён из дерева, или `false`, если его в дереве не было.

Спустимся по дереву. Если спустились в `nullptr` (то есть к виртуальному `end()`), то удалять ничего не надо, возвращаем `false`. Иначе начинаем от листа следующий процесс:
+ Поддерживаем текущую вершину `vertex`, из которой что-то удаляем и позицию в массивах ключей/детей, которую нужно удалить (`erasing_ind`). Поднимаемся пока !!!!!!!!!!!!!!!!!!!!!!!!1

+ Собственно производим удаление. В случае если мы находимся в листе мы потенциально могли удалить такой ключ, который был максимум в поддеревьях некоторого числа вершин. Потому вызываем `UpdateKeys`, а далее этот метод не нужно вызывать, так как после этого мы только будем перекладывать ключи и указатели, что не повлияет на вершины выше непосредственно предка удаляемой. Если же мы находимся не в листе, то помимо ключа надо удалить и ребёнка.

+ Если после удаления в вершине осталось более одного ключа/ребёнка, то дерево теперь полностью корректно, можно завершать исполнение (выходим из цикла и сразу делаем `return`).

+ Далее сохраняем родителя `parent` текущей вершины. Если его нет, значит мы удаляем ключ из корня. Дальше есть несколько вариантов:
    - Если у корня детей нет, значит мы удаляем второй ключ из двух, которые в принципе хранятся в дереве. Можем просто закончить исполнение на этом - корень останется листом, но хранящим один ключ. Увы, это корректное состояние.
    - Иначе же мы удалили одного из двух сыновей корня, а значит корень сейчас - вершина с одним сыном. Можно просто убрать корень и сделать корнем новую вершину. На том и завершиться.

+ Обработав случаи с корнем, мы переходим к основной части: родитель есть, в вершине один ключ. Его (и указатель на сына) нужно переложить к соседнему брату. Поэтому находим индекс `vertex` в массиве детей родителя `parent` и либо смотрим на сына перед нами, либо на следующего, если мы и так первый ребенок у родителя.

+ Обработка двух случаев симметрична. В случае если мы перекладываем к предыдущему (левому) брату ключ и ребенка, то необходимо добавить их в концы списков ключей и детей у брата, а также обновить ключ, хранимый в родителе для этого брата. При перекладывании информации к правому брату необходимо вставить информацию в начало, а не конец, а обновление ключа в родителе производить нет необходимости.

+ Далее мы хотим перейти к удалению из `parent`-а того сына, из которого мы сейчас переложили информацию. Но кроме того после перекладывания информации в брата, в нем могло оказаться 4 ключа. Тут возникает 2 случая:
    - Если в брате оказалось 4 ключа, то мы можем сначала просто удалить `vertex` из `parent` и вызвать процедуру разделения брата. Тогда после удаления вершины в `parent`-е будет 1 или 2 ребенка, но после разделения брата их станет 2 или 3. На этом можно будет закончить исполнение алгоритма.
    - Если в брате оказалось 3 ключа (меньше уж точно быть не может, так как должно было быть хотя бы 2, плюс 1 мы переложили), тогда необходимо просто перейти к удалению информации из `parent` по понятно какому индексу.

Оценим время работы. Сначала мы производим спуск по дереву за $O(\log n)$. Далее начинаем подниматься по предкам, в каждой вершине мы делаем $O(1)$ операций, а также один раз делаем `UpdateKeys` и один раз перед завершением можем вызвать `SplitNode`. Итого асимптотическая сложность - $O(\log n)$.


## Вспомогательные методы

Эти методы имеют модификатор доступа `private` по очевидным соображениям.

### Спуск по дереву
Метод `SearchByLowerBound(x)` работает следующим образом. Начинаем спуск из корня дерева. Далее, пока не дойдём до листа (а вершина является листом тогда и только тогда, когда у неё нет детей), повторяем следующий процесс: проходим по детям смотрим на максимальный ключ в их поддереве (обозначим как `key`). Если `x <= key`, то имеет смысл спуститься в соответствующего ребёнка вершины, так как это первая такая вершина (то есть имеем `keys[i - 1] < x <= keys[i]`, но это и значит что ключ лежит в диапазоне, соответствующем поддереву $i$-ого сына). Если же `x` оказался больше всех ключей в дереве, то мы хотим вернуть нечто вроде `std::set::end()`. В таком случае давайте вернем самый правый лист, так как в `keys.end()` можно вставить очень большой ключ, например.

Работает за высоту дерева, то есть $O(\log n)$.

### Обновление ключей
Метод `UpdateKeys(vertex)` предполагает, что ключи в вершине (листе) корректны и начинает от предка вершины - `vertex->parent`. Далее для каждой вершины список ключей создается заново путем прохода по сыновьям и копирования максимального ключа в поддереве каждого сына. 

Работает за высоту дерева, то есть $O(\log n)$.

Отметим, что в некоторых статьях (прим.: [Викиконспекты ИТМО](https://neerc.ifmo.ru/wiki/index.php?title=2-3_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)) предлагается для работы данной функции хранить отдельно в каждой вершине максимальный ключ в её поддереве. Но по сути он совпадает с максимальным ключом самого правого сына. Поэтому мы храним копии ключей из всех сыновей, а не всех кроме последнего - так получается консистентнее.

### Разделение вершины
Метод `SplitNode(vertex)`, начиная с `vertex`, идёт по вершинам, пока в них слишком много ключей. Далее, в качестве замены разрезаемой вершины, создаются две новые вершины, в которые перекладываются ключи и указатели на детей. Далее указатели на эти две вершины вставляются в предка заместо указателя на `vertex`. После того, как количество детей в предке увеличилось, в нём могло тоже стать 4 ребёнка. Поэтому мы переходим к родителю и пытаемся разделить его.

На каждом уровне все операции с созданием вешин и перекладыванием информации работают за $O(1)$, значит асимптотика работы - $O(h) = O(\log n)$.

### Проверка инварианта
Метод `CheckInvariants(vertex)` рекурсивно обходит дерево и проверяет инварианты в каждой вершине. Он **не** необходим при реализации и необходим только для тестирования работоспособности дерева в рамках проекта.

# Дополнительная информация

## Слияния и разделения
Помимо описанных выше и используемых в проекте операций 2-3 Дерево позволяет также выполнять операции слияния двух деревьев с непересекающимся диапазноном ключей, а также разделение дерева на два по ключу.

Первая операция работает за **разность высот** сливаемых деревьев. Более того, зная этот факт несложно догадаться как её реализовать: достаточно спуститься по более высокому дереву и добавить корень меньшего дерева на необходимый уровень. А затем просто разделить новоявленного родителя у _в прошлом_ корня меньшего дерева.

Вторая операция явно сложнее, её описания в убедительном виде я пока не нашёл (TODO), поэтому ограничусь маханием руками. Звучит правдоподобным следующий алгоритм. Будем разделять дерево по ключу рекурсивной процедурой. Сначала найдём сына, в диапазон ключей которого попадает ключ-разделитель. Далее разделим этого сына рекурсивно, получив два новых дерева вместо него, и далее нужно слить левых братьев этого сына с левым из получившихся деревьев. Аналогично слить правых братьев и правое поддерево после разделения. Сливать можно описанной выше процедурой. Тогда суммарное время работы сложится из суммы разностей высот промежуточных сливаемых деревьев. Эти высоты, вроде как, должны телескопически свернуться и тогда время работы выйдет равным сумме высот двух получившихся деревьев, то есть $O(\log n)$.

## B+-дерево
На самом деле описанная структура данных является частным случаем $B+$-дерева. В каждом узле такого дерева хранится не 2 или 3 ключа/ребёнка, а от $t$ до $2t-1$ ключей и детей (рассмотрите $t=2$ и получите 2-3 Дерево!). Все реализованные операции для 2-3 Дерева реализуются подобным образом для $B+$-дерева. Кроме операции удаления, в которой появляются ещё случаи при удалении. Какая же она неприятная...

### B или B+
Под 2-3 Деревом иногда понимают не частный случай $B+$-дерева, а частный случай $B$-дерева. По описанию оно похоже на $B+$, но хранит оригиналы ключей в единственном экземпляре во всех своих вершинах (в то время как $B+$ только в листьях). Из-за этого чуть сложнее становится поиск в дереве и удаление.

